<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    // Задание 1
    // Создать массив «Список покупок». Каждый элемент массива
    // является объектом, который содержит название продукта, необ-
    // ходимое количество и куплен или нет. Написать несколько функ-
    // ций для работы с таким массивом.


//     class Product{
// constructor (name, quantity, isBought)
// {
//     this.name=name;
//     this.quantity=quantity;
//     this.isBought=isBought;
// }
// Buy()
// {
//     if(this.isBought==true){
//         let str=' is (are) bought';
//      return str;
//     }
//     else {
//         let str=' is (are)n`t bought';
//         return str;
//     }
// }
//
// display(){
//     console.log(this.quantity+' '+this.name+this.Buy() );
// }
//     }
//
//     let shopList=[new Product('apple', 2,true),new Product('ice-cream', 4, true), new Product('eggs', 10,false) ];
// let i=0;
//     function masDisplay(shopList) {
//
//         for(let i=0;i<shopList.length;i++)
//         {
//             shopList[i].display();
//         }
//     }


    //-- 1. Вывод всего списка на экран таким образом, чтобы сначала
    //-- шли некупленные продукты, а потом – купленные.

    //    function bought(a) {
    //     if(a.isBought===false)
    //     {return -1;}
    //     else
    //     {return 1;}
    // }
    //
    //
    //     for  ( i=0; i<shopList.length;i++)
    //     {
    //         shopList.sort(bought);
    //         // document.write(shopList.join(", "));
    //         shopList[i].display();
    //     }

    // --2. Добавление покупки в список. Учтите, что при добавлении
    //-- покупки с уже существующим в списке продуктом, необ-
    //-- ходимо увеличивать количество в существующей покупке,
    // --    а не добавлять новую.

    // let flag=false;
    // let p =new Product('apple', 5, false);
    // for(let i=0;i<shopList.length;i++) {
    //  if (shopList[i].name === p.name) {
    //     shopList[i].quantity += p.quantity;
    //     flag=true;
    //  }
    // }
    // if(flag===false)
    //     {
    //         shopList.push(p);
    //     }
    //
    // masDisplay(shopList);

    //-- 3. Покупка продукта. Функция принимает название продукта
    // --и отмечает его как купленный.

    // masDisplay(shopList);
    //
    // shopList.Bought=Bought;
    // function Bought(pname) {
    //     for (let i=0;i<shopList.length;i++)
    //     {
    //         if(shopList[i].name===pname)
    //         {
    //             shopList[i].isBought=true;
    //         }
    //
    //     }
    // }
    // shopList.Bought('eggs');
    // masDisplay(shopList);


    //     Задание 2
    // Создать массив, описывающий чек в магазине. Каждый эле-
    // мент массива состоит из названия товара, количества и цены за
    // единицу товара. Написать следующие функции.
    // 1. Распечатка чека на экран.
    // 2. Подсчет общей суммы покупки.

   //  class  Product
   //  {
   //      constructor(pName,pQuantity, pPrice)
   //      {
   //          this.name=pName;
   //          this.quantity=pQuantity;
   //          this.price=pPrice;
   //      }
   //      display() {
   //          console.log(this.quantity + ' ' + this.name +' are '+ this.price+' uar');
   //      }
   //
   //  }
   //
   // let cheque=[new Product('carrot', 3, 15.25), new Product('milk',1, 15), new Product('bread', 2, 18.03)];
   //
   //  function chequeDisplay(cheque) {
   //
   //          for(let i=0;i<cheque.length;i++)
   //          {
   //              cheque[i].display();
   //          }
   //      }
   //  chequeDisplay(cheque);
   //
   //  cheque.result=result;
   //  function result() {
   //      let sum=0;
   //      for(let i=0; i<cheque.length;i++)
   //      {
   //
   //          sum+=cheque[i].price;
   //      }
   //      // console.log('The summary is '+ sum+ 'uar');
   //      return sum;
   //
   //  }
   //
   //  cheque.result();
   //  // Домашнее задание №2
   //  // 3. Получение самой дорогой покупки в чеке.
   //  cheque.Max=Max;
   //  function Max() {
   //      let maxNumb=0;
   //      for(let i=0; i<cheque.length;i++)
   //      {
   //           if(cheque[i].price>maxNumb)
   //          {
   //              maxNumb=cheque[i].price;
   //
   //          }
   //      }
   //      for(let i=0; i<cheque.length;i++)
   //      {
   //
   //          if(cheque[i].price===maxNumb)
   //          {
   //              console.log('the most expensive product is ' + (cheque[i].name));
   //          }
   //      }
   //   }
   //  cheque.Max();
   //  // 4. Подсчет средней стоимости одного товара в чеке.
   //  cheque.avg=avg;
   //  function avg() {
   //      let res=result();
   //      let avgNumb=(res/cheque.length).toFixed(3);
   //      console.log('the Average price is '+avgNumb);
   //  }
   //  cheque.avg();


    //     Задание 3
    // Создать массив css-стилей (цвет, размер шрифта, выравнива-
    // ние, подчеркивание и т. д.). Каждый элемент массива – это объ-
    // ект, состоящий из двух свойств: название стиля и значение стиля.
    //     Написать функцию, которая принимает массив стилей и
    // текст, и выводит этот текст с помощью document.write() в тегах
    // <p></p>, добавив в открывающий тег атрибут style со всеми сти-
    // лями, перечисленными в массиве.
//     class Style{
//         constructor(pName,pValue){
//             this.Name=pName;
//             this.Value=pValue;
//         }
//         getstyle(){
//             return(this.Name+':'+this.Value);
//         }
//     }
//     let styles=[new Style('background-color', 'red'), new Style('font-size', '45px'), new Style("text-decoration", "underline")];
//     styles.display=display;
//
//         function display(text) {
//             for(let i=0;i<styles.length;i++)
//             {
//
//            document.write(`<p style="${styles[i].getstyle()}">${text}</p>`);
//             }
// // document.write(<p> text</p>)
//     }
//     styles.display('abcdefghgkl');

    //     Задание 4
    // Создать массив аудиторий академии. Объект-аудитория со-
    // стоит из названия, количества посадочных мест (от 10 до 20) и
    // названия факультета, для которого она предназначена.
    //     Написать несколько функций для работы с ним.
    // 1. Вывод на экран всех аудиторий.
    // 2. Вывод на экран аудиторий для указанного факультета.
    // 3. Вывод на экран только тех аудиторий, которые подходят для
    // переданной группы. Объект-группа состоит из названия,
    //     количества студентов и названия факультета.
    // 4. Функция сортировки аудиторий по количеству мест.
    // 5. Функция сортировки аудиторий по названию (по алфа-
    // виту).
    class Room{
        constructor(pName,Place, faculty){
            this.Name=pName;
            this.Place=Place;
            this.Faculty=faculty;
        }
        display_one() {
            console.log(this.Name + ' room has ' + this.Place +' places and is for '+ this.Faculty+' faculty');
            }

    }
    let rooms=[new Room(305, 80, 'Foreign languages' ), new Room(203, 30, 'ukranian filology'),new Room(315, 30, "psychology")];
    let room=new Room(112, 25, 'Foreign languages');
   rooms.push(room);
    rooms.display=display;
    function display() {
        for(let i=0;i<rooms.length;i++)
        {
            rooms[i].display_one();
        }

    }
    // rooms.display()
    // rooms.Faculty_room=Faculty_room;
    // function Faculty_room(faculty) {
    //     for (let i=0;i<rooms.length;i++){
    //         if(rooms[i].Faculty==faculty)
    //         {
    //             rooms[i].display_one();
    //         }
    //     }
    // }
    // rooms.Faculty_room('Foreign languages');
    class Group{
        constructor(pName, pStudent,pFaculty){
            this.Name=pName;
            this.Quantity=pStudent;
            this.faculty=pFaculty;
        }
    }
    let group=new Group('GED-15', 26,'Foreign languages');
    rooms.Group_room=Group_room;
    function Group_room(group) {
        for (let i=0;i<rooms.length;i++){
            if(rooms[i].Faculty==group.faculty&&rooms[i].Place>=group.Quantity)
            {
                rooms[i].display_one();

            }
        }

    }
    rooms.Group_room(group);
    // function compare(r1,r2)
    // {
    //     if(r.places > r2.places) {return -1}
    //     if(r2.places > r1.places) {return 1}
    // }
    // function sort_places()
    // {
    //     rooms.sort(compare);
    //     view_all();
    // }
    // sort_places();
    // rooms.sort((a,b) => (a.Place > b.Place) ? 1 : ((b.Place > a.Place) ? -1 : 0));
    // rooms.display();
    rooms.sort((a,b) => (a.Name > b.Name) ? 1 : ((b.Name > a.Name) ? -1 : 0));
    rooms.display();
</script>
</body>
</html>